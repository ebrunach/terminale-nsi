{"cells":[{"metadata":{"editable":false,"deletable":false},"cell_type":"markdown","source":"# TP - Arbres binaires - Parcours\n\n## 1. Arbres binaires\n\nOn utilisera dans ce TP l'implémentation des arbres binaire suivante utilisant les classes."},{"metadata":{"trusted":false},"cell_type":"code","source":"class Arbre:\n    def __init__(self, etiquette):\n        self.etiquette = etiquette\n        self.droite = None\n        self.gauche = None\n    \n        \nmon_arbre = Arbre(\"P\")\nmon_arbre.gauche = Arbre(\"Y\")\nmon_arbre.droite = Arbre(\"T\")\nmon_arbre.gauche.gauche = Arbre(\"H\")\nmon_arbre.gauche.droite = Arbre(\"O\")\nmon_arbre.droite.gauche = Arbre(\"N\")","execution_count":1,"outputs":[]},{"metadata":{"editable":false,"deletable":false},"cell_type":"markdown","source":"Ceci devrait modéliser l'arbre suivant:\n\n![arbre1](https://capytale2.ac-paris.fr/web/sites/default/files/2023/01-30/17-00-51/arbre1.png)"},{"metadata":{"editable":false,"deletable":false},"cell_type":"markdown","source":"## 2. Quelques méthodes pratiques\n\n### 2.1 Est feuille ?\n\nAjouter une méthode `est_feuille` retournant `True` si l'arbre n'a ni sous arbre gauche, ni sous arbre droit."},{"metadata":{"trusted":false},"cell_type":"code","source":"class Arbre:\n    def __init__(self, etiquette):\n        self.etiquette = etiquette\n        self.droite = None\n        self.gauche = None\n    \n    def est_feuille(...):\n        ...","execution_count":null,"outputs":[]},{"metadata":{"editable":false,"deletable":false},"cell_type":"markdown","source":"### 2.2 Taille\n\nAjouter une méthode récursive `taille` à la classe Arbre retournant la taille d'un arbre. La méthode est la suivante:\n\n```\nà partir de la racine:\n - récupérer la taille du sous arbre gauche si il existe\n - récupérer le taille du sous arbre droite si il existe\n - ajouter les deux et compter le noeud lui-meme.\n```"},{"metadata":{"trusted":false},"cell_type":"code","source":"class Arbre:\n    def __init__(self, etiquette):\n        self.etiquette = etiquette\n        self.droite = None\n        self.gauche = None\n        \n    def taille(self):\n        if selg.gauche is not None:\n            taille_g = ...\n        if ...:\n            ...\n        return ...","execution_count":null,"outputs":[]},{"metadata":{"editable":false,"deletable":false},"cell_type":"markdown","source":"### Hauteur\n\nAjouter une méthode récursive `hauteur`à la classe Arbre retournant la hauteur d'un arbre. La méthode est la suivante:\n\n```\nà partir de la racine:\n - récupérer la hauteur du sous arbre gauche si il existe\n - récupérer la hauteur du sous arbre droite si il existe\n - prendre le max des deux sous-arbres et compter le noeud lui-meme.\n```"},{"metadata":{"trusted":false},"cell_type":"code","source":"class Arbre:\n    def __init__(self, etiquette):\n        self.etiquette = etiquette\n        self.droite = None\n        self.gauche = None\n        \n    def hauteur(self):\n        ...","execution_count":null,"outputs":[]},{"metadata":{"editable":false,"deletable":false},"cell_type":"markdown","source":"## 3. Parcours\n\nOn souhaite réaliser des parcours de ce graphe à l'aide de trois méthodes de la classe arbre: `parcours_préfixe`, `parcours_infixe` et `parcours_postfixe`.\n\nLes résultats prévus sont les suivants:\n```python\n>>> mon_arbre.parcours_prefixe()\n'PYHOTN'\n>>> mon_arbre.parcours_infixe()\n'HYOPNT'\n>>> mon_arbre.parcours_postfixe()\n'HOYNTP'\n```\n\n### 3.1 Préfixe\n\n1. Compléter la méthode récursive de la classe Arbre ci-dessous pour réaliser le parcours préfixe"},{"metadata":{"trusted":false},"cell_type":"code","source":"class Arbre:\n    def __init__(self, etiquette):\n        self.etiquette = etiquette\n        self.droite = None\n        self.gauche = None\n        \n    def parcours_prefixe(self):\n        ch = ...\n        if self.gauche is not None:\n            ch += self.gauche...\n        if self.droite is not None:\n            ...\n        return ch\n    \nmon_arbre = Arbre(\"P\")\nmon_arbre.gauche = Arbre(\"Y\")\nmon_arbre.droite = Arbre(\"T\")\nmon_arbre.gauche.gauche = Arbre(\"H\")\nmon_arbre.gauche.droite = Arbre(\"O\")\nmon_arbre.droite.gauche = Arbre(\"N\")\nassert mon_arbre.parcours_prefixe() == 'PYHOTN'","execution_count":1,"outputs":[]},{"metadata":{"editable":false,"deletable":false},"cell_type":"markdown","source":"2. Combien d'appels à la fonction `parcours_prefixe` sont réalisés lors de l'appel `mon_arbre.parcours_prefixe()` ?"},{"metadata":{"editable":false,"deletable":false},"cell_type":"markdown","source":"### 3.2 Infixe et postfixe\n\n1. Sur le même modèle créer les méthode infixe et postfixe de la classe Arbre"},{"metadata":{"trusted":false},"cell_type":"code","source":"class Arbre:\n    def __init__(self, etiquette):\n        self.etiquette = etiquette\n        self.droite = None\n        self.gauche = None\n        \n    def parcours_infixe(self):\n        ...\n    \n    def parcours_postfixe(self):\n        ...\n    \nmon_arbre = Arbre(\"P\")\nmon_arbre.gauche = Arbre(\"Y\")\nmon_arbre.droite = Arbre(\"T\")\nmon_arbre.gauche.gauche = Arbre(\"H\")\nmon_arbre.gauche.droite = Arbre(\"O\")\nmon_arbre.droite.gauche = Arbre(\"N\")\nassert mon_arbre.parcours_infixe() == 'HYOPNT'\nassert mon_arbre.parcours_postfixe() == 'HOYNTP'","execution_count":null,"outputs":[]},{"metadata":{"editable":false,"deletable":false},"cell_type":"markdown","source":"2. Refaire les trois parcours de manière à renvoyer une liste des étiquettes au lieu d'une chaine de caractères.\n\nExemple:\n```python\n>>> mon_arbre.parcours_infixe_liste()\n['H','Y','O','P','N','T']\n```"},{"metadata":{"trusted":false},"cell_type":"code","source":"","execution_count":null,"outputs":[]},{"metadata":{"editable":false,"deletable":false},"cell_type":"markdown","source":"### 3.3 Parcours en largeur\n\n1. Réfléchir à un algorithme de parcours en largeur"},{"metadata":{},"cell_type":"markdown","source":"Idées: "},{"metadata":{"editable":false,"deletable":false},"cell_type":"markdown","source":"2. Implémenter une méthode `parcours_largeur` de la classe Arbre renvoyant une liste des étiquettes en réalisant un parcours en largeur."},{"metadata":{"trusted":true},"cell_type":"code","source":"","execution_count":null,"outputs":[]}],"metadata":{"kernelspec":{"name":"python3","display_name":"Python 3","language":"python"},"celltoolbar":"Format de la Cellule Texte Brut"},"nbformat":4,"nbformat_minor":2}